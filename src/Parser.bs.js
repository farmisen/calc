// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Caml_js_exceptions = require("bs-platform/lib/js/caml_js_exceptions.js");

var ParsingError = Caml_exceptions.create("Parser-Calc.ParsingError");

function parse(tokens) {
  var doParse = function (tokens) {
    if (!tokens) {
      return /* Empty */0;
    }
    var value = tokens.hd;
    if (typeof value !== "number") {
      var value$1 = value._0;
      var tokens$1 = tokens.tl;
      if (!tokens$1) {
        return /* Node */{
                _0: /* Number */{
                  _0: value$1
                },
                _1: /* Empty */0,
                _2: /* Empty */0
              };
      }
      var match = tokens$1.hd;
      if (typeof match === "number") {
        switch (match) {
          case /* Plus */0 :
              return /* Node */{
                      _0: /* Plus */0,
                      _1: /* Node */{
                        _0: /* Number */{
                          _0: value$1
                        },
                        _1: /* Empty */0,
                        _2: /* Empty */0
                      },
                      _2: doParse(tokens$1.tl)
                    };
          case /* Minus */1 :
              return /* Node */{
                      _0: /* Minus */1,
                      _1: /* Node */{
                        _0: /* Number */{
                          _0: value$1
                        },
                        _1: /* Empty */0,
                        _2: /* Empty */0
                      },
                      _2: doParse(tokens$1.tl)
                    };
          case /* Multiply */2 :
              return /* Node */{
                      _0: /* Multiply */2,
                      _1: /* Node */{
                        _0: /* Number */{
                          _0: value$1
                        },
                        _1: /* Empty */0,
                        _2: /* Empty */0
                      },
                      _2: doParse(tokens$1.tl)
                    };
          case /* Divide */3 :
              return /* Node */{
                      _0: /* Divide */3,
                      _1: /* Node */{
                        _0: /* Number */{
                          _0: value$1
                        },
                        _1: /* Empty */0,
                        _2: /* Empty */0
                      },
                      _2: doParse(tokens$1.tl)
                    };
          case /* OpenParens */4 :
          case /* CloseParens */5 :
          case /* EOF */6 :
              throw {
                    RE_EXN_ID: ParsingError,
                    _1: "unexpected token",
                    Error: new Error()
                  };
          
        }
      } else {
        throw {
              RE_EXN_ID: ParsingError,
              _1: "unexpected token",
              Error: new Error()
            };
      }
    }
    if (value !== 4) {
      throw {
            RE_EXN_ID: ParsingError,
            _1: "unexpected token",
            Error: new Error()
          };
    }
    var tokens$2 = tokens.tl;
    var extractExpression = function (_tokens, _nesting, _expression) {
      while(true) {
        var expression = _expression;
        var nesting = _nesting;
        var tokens = _tokens;
        if (!tokens) {
          return [
                  List.rev(expression),
                  /* [] */0
                ];
        }
        var tail = tokens.tl;
        var head = tokens.hd;
        if (typeof head === "number" && head >= 4) {
          switch (head - 4 | 0) {
            case /* Plus */0 :
                _expression = {
                  hd: head,
                  tl: expression
                };
                _nesting = nesting + 1 | 0;
                _tokens = tail;
                continue ;
            case /* Minus */1 :
                if (nesting === 1) {
                  return [
                          List.rev(expression),
                          tail
                        ];
                }
                _expression = {
                  hd: head,
                  tl: expression
                };
                _nesting = nesting - 1 | 0;
                _tokens = tail;
                continue ;
            case /* Multiply */2 :
                break;
            
          }
        }
        _expression = {
          hd: head,
          tl: expression
        };
        _tokens = tail;
        continue ;
      };
    };
    var match$1 = extractExpression(tokens$2, 1, /* [] */0);
    var tail = match$1[1];
    var parsed = doParse(match$1[0]);
    if (!tail) {
      return parsed;
    }
    var match$2 = tail.hd;
    if (typeof match$2 === "number") {
      switch (match$2) {
        case /* Plus */0 :
            return /* Node */{
                    _0: /* Plus */0,
                    _1: parsed,
                    _2: doParse(tail.tl)
                  };
        case /* Minus */1 :
            return /* Node */{
                    _0: /* Minus */1,
                    _1: parsed,
                    _2: doParse(tail.tl)
                  };
        case /* Multiply */2 :
            return /* Node */{
                    _0: /* Multiply */2,
                    _1: parsed,
                    _2: doParse(tail.tl)
                  };
        case /* Divide */3 :
            return /* Node */{
                    _0: /* Divide */3,
                    _1: parsed,
                    _2: doParse(tail.tl)
                  };
        case /* OpenParens */4 :
        case /* CloseParens */5 :
        case /* EOF */6 :
            throw {
                  RE_EXN_ID: ParsingError,
                  _1: "unexpected token",
                  Error: new Error()
                };
        
      }
    } else {
      throw {
            RE_EXN_ID: ParsingError,
            _1: "unexpected token",
            Error: new Error()
          };
    }
  };
  try {
    return {
            TAG: /* Ok */0,
            _0: doParse(tokens)
          };
  }
  catch (raw_msg){
    var msg = Caml_js_exceptions.internalToOCamlException(raw_msg);
    if (msg.RE_EXN_ID === ParsingError) {
      return {
              TAG: /* Error */1,
              _0: msg._1
            };
    }
    throw msg;
  }
}

exports.ParsingError = ParsingError;
exports.parse = parse;
/* No side effect */
